---
title: "Blood donor recruitment prediction: data load and analysis"
author: "Timo Asikainen"
date: "`r Sys.time()`"
output:
  html_document:
  toc: true
theme: united
---
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(openxlsx)
library(ggplot2) # # heatmaps etc
library(reshape2) # melt (needed in heatmaps)
```

GitHub: https://github.com/FRCBS/donor-recruitment-prediction/blob/main/src/blood-donor-recruitment-prediction.Rmd


# Parameters

```{r parameters} 
param=list()
param$data.directory = 'C:/git_repot/donor-recruitment-prediction/data' # '/data'
```


```{r read-files}
file.names = dir(path=param$data.directory,pattern="*.xlsx")
file.names = file.names[!grepl('~',file.names)]
file.names = file.names[grepl('.xlsx$',file.names)]
file.paths = paste(param$data.directory,'/',file.names,sep='')

countries = list()
gt = NULL
for (file in file.paths) {
  identifier = sub('.+[/\\]([a-z]+)[^/\\]+$','\\1',file) # gsub('.*\\\\(..).*\\.xlsx$','\\1',file)
  
  curr = list()
  res = list()
  
  sheet.names = getSheetNames(file)
  for (sn in sheet.names) {
    data = read.xlsx(file,colNames=TRUE,rowNames=TRUE,sheet = sn)
    if (grepl(' def(inition)?$',sn)) {
      if (is.null(gt)) {
        gt = data
      } else
        gt = rbind(gt,data)
    } else if (sn == 'parameters') {
      curr$parameters = data
    } else if (grepl('sizes',sn)) {
        grp = list()
        grp$sizes = data
        rownames(grp$sizes) = grp$sizes$year
    } else if (grepl('distm|dista',sn)) {
      kind = sub('.+(distm|dista)','\\1',sn)
      if (kind == 'distm') {
        # There is an error in data generation: the columns start repeating
        # Remove the extra columns here
        ncols = which.max(colSums(is.na(data)))
        grp[[kind]] = as.matrix(data[,1:(ncols-0)])
      }
      if (kind == 'dista') {
        grp[[kind]] = data
        res[[length(res)+1]] = grp
      }
    } else if (grepl('^activity-stats',sn)) {
      # print('hit')
      # print(sn)
      # print(str(data))
      data$delay = as.numeric(data$delay)
      data$prop = as.numeric(data$prop) 
      if (grepl('sex',sn))
        data = data[data$Sex!="",]
      curr[[gsub('-','.',sn)]] = data
    } else {
      print(paste('not processed',sn))
    }
  }
  
  
  
  curr$gt = gt
  gt = NULL
  curr$res = res
  countries[[identifier]] = curr
}
```

```{r produce-explore-data}
# This is a copy from blood-donor-recruitment-prediction.R
# Unfortunately does not work for matrices
cumulativeToDensity = function(dist) {
  return((c(dist,0)-c(0,dist))[1:length(dist)])
}

cdm2pdm = function(distm) {
  pdm = cbind(cdm)-cbind(data.frame(rep(0,nrow(cdm))),cdm[,-ncol(cdm)])
  colnames(pdm)=colnames(distm)
  return(pdm)
}

et=NULL
for (cn in names(countries)) {
  country = countries[[cn]]
  for (i in 1:nrow(country$gt)) {
    gt.row = cbind(country=cn,country$gt[i,])
    rese = country$res[[i]]
    cdm = rese$distm
    pdm = cdm2pdm(cdm)
    
    m_longer = function(cdm) {
      cdm = data.frame(cdm)
      cdm = cbind(year0=rownames(cdm),cdm)
      cdm= pivot_longer(cdm,colnames(cdm)[2:ncol(cdm)])
      colnames(cdm)=c('year0','ord','value')
      cdm$ord = as.integer(sub('X','',cdm$ord))
      return(cdm)
    }
    
    dista = rese$dista
    cols = colnames(dista)[-1]
    dista[cols] = lapply(dista[cols],FUN=cumulativeToDensity)

    avgage = dista %>%
      pivot_longer(colnames(dista)[-1]) %>%
      group_by(name) %>%
      summarise(avage=sum(age*value,na.rm=TRUE)) %>%
      mutate(year=as.integer(name))
    
    lcm=m_longer(cdm)
    lpm=m_longer(pdm)
    huu=cross_join(gt.row,lcm)
    colnames(huu)=sub('value','cdon',colnames(huu))
    hu2=inner_join(huu,lpm,join_by(year0,ord))
    colnames(hu2)=sub('value','don',colnames(hu2))
    hu2$year0=as.integer(hu2$year0)
    hu2 = inner_join(hu2,avgage,join_by(closest(x$year0<=y$year)))
    hu2 = hu2[,-ncol(hu2)] # remove the age column from avgage
    hu2$avage = (hu2$avage + hu2$ord) - 1  # compute the average age for subsequent year
    hu2 = hu2[,!colnames(hu2) %in% c('name')]
    hu2$year = (hu2$year0+hu2$ord) - 1
    int.cols = c('age.lower','age.upper','MaximumAge','year')
    hu2[int.cols] = lapply(hu2[int.cols],as.integer)
    if (is.null(et)) {
      et = hu2
    } else
      et =rbind(et,hu2)
  }
}
```


```{r}
# These values are experimental in the data, so quick-fix them here
countries$fi$parameters$reference.year = 2003
countries$fi$parameters$last.data.year = 2023

countries$nl$parameters$reference.year = 2011
countries$nl$parameters$last.data.year = 2023
```

```{r}
for (i in 1:length(countries$nl$res)) {
  plotDistibutionMatrix(countries$nl$res[[i]]$distm,diff=FALSE,skip.years=1,main=countries$nl$gt$Name)
}
```

```{r estimate-models}
# Here, the data is augmented with models estimated based on distm
for (m in names(countries)) {
  for (i in 1:length(countries[[m]]$res)) {
    params = countries[[m]]$parameters
    last.data.year = params$last.data.year
    ref.year = as.character(params$reference.year)
    m0 = estimate.predict(countries[[m]]$res[[i]]$distm,ref.year=ref.year,last.data.year=last.data.year,years.ahead=55,main='')
    countries[[m]]$res[[i]]$m = m0
  }
}
```

```{r}
# This is a slighty modified version of plot.estimted in blood-donor-recruitment-prediction.R
plot.estimated.countries = function(nres,gt,bundle=FALSE,years.ahead=55,main='') {
  # Here, gt contains reference year and last.data year values (per country)
  
  models=list()
  for (i in 1:length(nres)) {
    group = nres[[i]]
    ms = estimate.predict(group$distm,
                    ref.year=gt[i,'reference.year'],last.data.year=gt[i,'last.data.year'],
                     main = if (bundle) '' else gt$Name[i],
                     sub=paste('n=',dim(group$data)[1],sep=''),try.nls=TRUE)
    
    models[[i]] = ms$m
  }
  
  mean.y = NULL
  
  # Create a plot with all the model estimates if requested
  if (bundle) {
    # nb! should set a reasonable value for the maximum
    plot(x=NULL,type='n',xlim=c(0,55),ylim=c(0,20),main=main,ylab='cumulative number of donations',xlab='years since first donation')
    for (i in 1:length(models)) {
      new=data.frame(x=0:years.ahead,sqrt.x=(0:years.ahead)^0.5)
      pred.w.plim <- predict(models[[i]], new, interval = "prediction")
      # pred.w.clim <- predict(models[[i]], new, interval = "confidence")
      lines(new$x, pred.w.plim[,1],lwd=3,col=i+1)
      lines(new$x, pred.w.plim[,2],lwd=1,col=i+1,lty='dashed')
      lines(new$x, pred.w.plim[,3],lwd=1,col=i+1,lty='dashed')
      points(models[[i]]$model$x,models[[i]]$model$y,col=i+1)
      legend('topleft',legend=gt$Name,fill=1+(1:length(models)))
    }
    
    if (length(models)==2) {
      # Plot the proportion as well to enable comparisons
      # Primarily intended to estimate the excess donations by Oneg donors
      min.len = min(length(models[[1]]$model$y),length(models[[2]]$model$y))
      lines(models[[1]]$model$x[1:min.len], models[[1]]$model$y[1:min.len]/models[[2]]$model$y[1:min.len],lwd=5,lty='dotted')
      mean.y=mean(models[[1]]$model$y[1:min.len]/models[[2]]$model$y[1:min.len])
      text(x=30,y=mean.y,labels=paste('ratio =',round(mean.y,3)))
    }
  }
  
  return(mean.y)
}
```


```{r}
# Plot the countrywise comparisons for each group
# nb!/todo Could also make comparisons based on the estimated parameters: integrate over a given range
for (i in 1:length(countries$nl$res)) {
  local.gt = NULL
  local.res = list()
  for (m in names(countries)) {
    if (is.null(local.gt)) {
      local.gt = countries[[m]]$gt[i,]
      ncol.gt = ncol(countries[[m]]$gt)
      rownames(local.gt) = m
    } else {
      local.gt[m,1:ncol.gt] = countries[[m]]$gt[i,]
    }
    local.res[[m]] = countries[[m]]$res[[i]]
    if (m == 'nl')
      local.res[[m]]$distm = local.res[[m]]$distm[,1:14]
    
    local.gt[nrow(local.gt),'reference.year'] = countries[[m]]$parameters$reference.year
    local.gt[nrow(local.gt),'last.data.year'] = countries[[m]]$parameters$last.data.year
  }
  
  # nb! hard-coded constant; the name is missing for some reason on the first line
  group.name = local.gt[2,'Name']
  local.gt$Name = names(countries)
  plot.estimated.countries(local.res,local.gt,bundle=TRUE,main=group.name)
}
# Change in hemoglobin accross countries
# Confidence intervals for predictions
# Countrwise comparisons
# Model could be estimated using splines
# Trends over time: some mixed model to see the trends over time
# Not yet hemoglobin
# 7th Jan
# Oneg thing to be included, highlight this; plots for this as well
# Split by
# - Oneg/others
# - Sex
# - (Age)
# - (Type of place)
```
```{r compute-donation-amounts}
dona=list()
for (m in names(countries)) {
  dona[[m]] = sumDonationAmounts(countries[[m]]$res,countries[[m]]$gt,FALSE,total.donations=NULL) 
}
```

```{r plot-donation-amounts}
for (m in names(countries)) {
  plotDonationAmounts(dona[[m]],countries[[m]]$gt)
}
```

```{r}
plot(x=NULL,type='n',xlim=c(0,200),ylim=c(0,100),xlab='number of previous donations',ylab='probability of next donation (%)')
for (i in 1:length(names(countries))) {
  stats = countries[[i]]$activity.stats
  lines(stats$ord,100*stats$prop,lwd=3,col=i+1)
}
legend('bottomright',legend=names(countries),fill=1+(1:length(countries)))

plot(x=NULL,type='n',xlim=c(0,200),ylim=c(0,600),xlab='number of previous donations',ylab='time till next donation')
for (i in 1:length(names(countries))) {
  stats = countries[[i]]$activity.stats
  lines(stats$ord,stats$delay,lwd=3,col=i+1)
}
legend('bottomright',legend=names(countries),fill=1+(1:length(countries)))

for (i in 1:length(names(countries))) {
  stats = countries[[i]]$activity.stats.sex
  plotPropBySex(stats,names(countries)[i])
}

for (i in 1:length(names(countries))) {
  stats = countries[[i]]$activity.stats.sex
  plotDelayBySex(stats,names(countries)[i])
}

# Divide both by sex
# Confidence intervals
```

```{r}
local.gt = countries$fi$gt
local.gt$reference.year = countries$fi$parameters$reference.year
local.gt$last.data.year = countries$fi$parameters$last.data.year
plot.estimated.countries(countries$fi$res,local.gt,bundle=FALSE)
```


```{r}
knitr::knit_exit()
```
